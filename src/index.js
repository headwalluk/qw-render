/**
 * index.js
 */

'use strict';

const fs = require('fs');
const path = require('path');
const htmlMinify = require('minify-html');

const self = {
  config: {
    htmlDocsDir: '',
    htmlPartialsDir: '',
    partialsFileMatch: /^[a-zA-Z0-9\-].*\.(s)?html$/,
    maxRecursion: 50,
    cache: {
      enabled: true,
    },
    minifyHtml: {
      enable: false,
      options: {
        includeAutoGeneratedTags: true,
        removeAttributeQuotes: true,
        removeComments: true,
        removeRedundantAttributes: false,
        removeScriptTypeAttributes: true,
        removeStyleLinkTypeAttributes: true,
        sortClassName: true,
        useShortDoctype: true,
        collapseWhitespace: true,
      },
    },
  },

  htmlOutputFilter: null,

  partials: null,
  fileCache: {},

  loadPartials: (dirName) => {
    const fileNames = fs.readdirSync(dirName);
    if (!Array.isArray(fileNames)) {
      throw Error(`loadPartials: Failed to read dir ${dirName}`);
    }

    self.htmlPartialsDir = dirName;

    if (!self.partials) {
      self.partials = {};
    }

    fileNames.forEach((fileName) => {
      if (fileName.match(self.config.partialsFileMatch)) {
        const fullPath = path.join(dirName, fileName);
        const slug = path.parse(fileName).name;

        // console.log(`Load partial: ${fileName} fullPath=${fullPath} slug=${slug}`);

        self.partials[slug] = {
          fileName,
          fullPath,
          slug,
          snippet: fs.readFileSync(fullPath).toString(),
        };
      }
    });
    // ...
  },

  render: (rawHtml) => {
    let html = new String(rawHtml);

    let isChanged = true;
    let iteration = 0;
    while (isChanged && iteration < self.config.maxRecursion) {
      isChanged = false;
      for (const slug in self.partials) {
        const tag = `{{{${slug}}}}`;
        const newHtml = html.replaceAll(tag, self.partials[slug].snippet);
        isChanged |= newHtml != html;
        html = newHtml;
      }

      ++iteration;
    }

    // console.log(`Renderer iterations: ${iteration}`);

    if (self.config.minifyHtml.enable) {
      html = htmlMinify.minify(html, self.config.minifyHtml.options);
    }

    return html;
  },

  sendFile: (req, res, htmlDocFileName) => {
    const fullPath = path.join(self.config.htmlDocsDir, htmlDocFileName);

    if (!fs.existsSync(fullPath)) {
      // res.set('Content-Type', 'text/plain');
      res.status(404).send({ message: 'NOT FOUND', fileName: htmlDocFileName });
    } else {
      let renderedHtml = '';

      if (self.config.cache.enabled && self.fileCache[fullPath]) {
        // console.log(`Cache hit: ${fullPath}`);
        renderedHtml = self.fileCache[fullPath].renderedHtml;
      } else {
        // console.log(`Cache miss: ${fullPath}`);

        const rawHtml = fs.readFileSync(fullPath);
        renderedHtml = self.render(rawHtml);

        if (self.config.cache.enabled) {
          self.fileCache[fullPath] = {
            rawHtml,
            renderedHtml,
          };
        }
      }

      if (self.htmlOutputFilter) {
        renderedHtml = self.htmlOutputFilter(renderedHtml, { req, res, htmlDocFileName });
      }

      if (!renderedHtml) {
        renderedHtml = '';
      }

      res.set('Content-Type', 'text/html');
      res.setHeader('Content-Length', `${renderedHtml.length}`);
      res.status(200).send(renderedHtml);
    }
  },
};

module.exports = self;
